const {
    GoogleGenerativeAI,
    HarmCategory,
    HarmBlockThreshold,
  } = require("@google/generative-ai");
  const fs = require("node:fs");
  const mime = require("mime-types");
  
  const apiKey = process.env.GEMINI_API_KEY;
  const genAI = new GoogleGenerativeAI(apiKey);
  
  const model = genAI.getGenerativeModel({
    model: "gemini-2.5-pro-exp-03-25",
  });
  
  const generationConfig = {
    temperature: 1,
    topP: 0.95,
    topK: 64,
    maxOutputTokens: 65536,
    responseModalities: [
    ],
    responseMimeType: "text/plain",
  };





    const chatSession = model.startChat({
      generationConfig,
      history: [
        {
          role: "user",
          parts: [
            {text: "job Position :fullstack Developer ,Job description : React ,python,Years of Experience:5\nDepends on those information please give me 5 interview questions  with answers in json format\ngive question and answer as fill in json"},
          ],
        },
        {
          role: "model",
          parts: [
            {text: "Here's my thinking process for generating the interview questions and answers in JSON format:\n\n1.  **Deconstruct the Request:**\n    *   **Job Position:** Fullstack Developer\n    *   **Key Skills:** React, Python\n    *   **Years of Experience:** 5 years\n    *   **Output Format:** JSON\n    *   **Output Structure:** 5 questions, each with a corresponding answer. The JSON should have fields for \"question\" and \"answer\".\n    *   **Goal:** Create relevant interview questions for a mid-level (5 years exp) fullstack developer focusing on React and Python, and provide plausible, detailed answers.\n\n2.  **Target Audience Analysis (Mid-Level Fullstack Dev - 5 years):**\n    *   **Expectations:** Beyond basic syntax and concepts. Should understand architecture, best practices, performance optimization, testing, and common patterns in both frontend (React) and backend (Python). Should be able to discuss trade-offs and design decisions.\n    *   **React:** Should know hooks, state management (beyond basic `useState`/`useReducer`, maybe context or libraries like Redux/Zustand), component lifecycle (even with hooks), performance optimization (memoization, code splitting), testing (Jest, React Testing Library), maybe SSR/Next.js concepts.\n    *   **Python:** Should be comfortable with core Python, common web frameworks (like Django or Flask, though not specified, it's implied for fullstack), database interaction (ORMs like SQLAlchemy or Django ORM), API design (REST principles), asynchronous programming (asyncio), testing (pytest/unittest), deployment concepts.\n    *   **Fullstack:** Should understand how frontend and backend interact (APIs, data flow, CORS, authentication/authorization), basic database concepts, maybe some DevOps/deployment knowledge.\n\n3.  **Brainstorming Question Categories (Mixing React, Python, Fullstack):**\n    *   **React Core Concepts (Advanced):** Hooks, state management choices, performance.\n    *   **Python Web Framework Concepts:** Request lifecycle, ORM usage, API design.\n    *   **Fullstack Integration:** How React and Python communicate, authentication flow.\n    *   **Architecture/Design:** Component design in React, API design in Python, state management strategy.\n    *   **Problem Solving/Scenario Based:** Debugging, performance bottlenecks, specific feature implementation.\n    *   **Testing:** Strategies for frontend and backend.\n    *   **Best Practices/Experience Based:** Code reviews, handling technical debt, working in a team.\n\n4.  **Drafting Specific Questions (Aiming for 5 diverse questions):**\n\n    *   **Question 1 (React State Management):** Focus on a common challenge for mid-level devs. \"Managing complex state...\" Compare Context API vs. Redux/Zustand. This tests understanding of trade-offs.\n        *   *Initial thought:* \"Explain Redux.\" - Too basic.\n        *   *Refinement:* \"When would you choose Context API over Redux (or a similar library like Zustand) for state management in a React application, and what are the potential drawbacks of using Context for complex global state?\" - Better, targets decision-making.\n\n    *   **Question 2 (Python Backend - ORM/Performance):** Focus on a common backend task and potential performance issue. Database interaction is key.\n        *   *Initial thought:* \"How do you connect to a database in Python?\" - Too basic.\n        *   *Refinement:* \"Describe the N+1 query problem often encountered with ORMs (like SQLAlchemy or Django ORM). How would you identify and resolve it in a Python backend application?\" - Tests specific ORM knowledge and performance awareness.\n\n    *   **Question 3 (Fullstack Integration - Authentication):** How do the two sides work together securely?\n        *   *Initial thought:* \"How does React talk to Python?\" - Too vague.\n        *   *Refinement:* \"Can you walk me through a common authentication flow (e.g., using JWT) between a React frontend and a Python (e.g., Flask/Django) backend? Describe the key steps on both the client and server sides.\" - Specific, practical, covers both ends.\n\n    *   **Question 4 (React Performance):** Target optimization, a key concern in frontend.\n        *   *Initial thought:* \"How to make React faster?\" - Too broad.\n        *   *Refinement:* \"What are `React.memo`, `useMemo`, and `useCallback`? Explain their purposes and provide scenarios where you would use each to optimize performance in a React application.\" - Tests knowledge of specific React optimization tools.\n\n    *   **Question 5 (Python API Design/Best Practices):** Focus on backend design principles.\n        *   *Initial thought:* \"What is REST?\" - Too definitional.\n        *   *Refinement:* \"When designing a RESTful API endpoint in Python for updating a resource (e.g., a user profile), what HTTP method would you typically use? What status codes are appropriate for success and different types of errors (e.g., resource not found, validation error)?\" - Tests practical API design knowledge and HTTP standards.\n\n5.  **Developing Answers:**\n    *   For each question, craft a detailed answer appropriate for a 5-year experienced developer.\n    *   **Answer 1 (State Management):** Explain Context API's simplicity for low-frequency updates/smaller trees vs. Redux/Zustand for complex, frequent updates. Mention Context's performance drawback (re-renders).\n    *   **Answer 2 (N+1 Problem):** Define the problem clearly (one query for parent, N queries for children). Explain identification (logging SQL, profiling tools). Describe solutions (e.g., `select_related`/`prefetch_related` in Django, `joinedload`/`selectinload` in SQLAlchemy).\n    *   **Answer 3 (Auth Flow):** Detail the steps: Login request (user/pass) -> Server validates, generates JWT -> Server sends JWT back -> Client stores JWT (localStorage/sessionStorage/cookie) -> Client sends JWT in `Authorization` header for subsequent requests -> Server validates JWT on protected routes. Mention refresh tokens as a potential enhancement.\n    *   **Answer 4 (React Optimization):** Define each hook (`React.memo` for components, `useMemo` for values, `useCallback` for functions). Explain the goal (preventing unnecessary re-renders). Give clear use cases (e.g., `memo` for pure components, `useMemo` for expensive calculations, `useCallback` for passing stable functions to child components/dependency arrays).\n    *   **Answer 5 (API Design):** State `PUT` or `PATCH` (and the difference). List key status codes: `200 OK` (or `204 No Content` if applicable), `404 Not Found`, `400 Bad Request` (for validation errors), `401 Unauthorized`, `403 Forbidden`. Briefly explain *why* each is used.\n\n6.  **Formatting as JSON:**\n    *   Create a root JSON array `[]`.\n    *   For each question/answer pair, create a JSON object `{}`.\n    *   Inside each object, add two key-value pairs: `\"question\": \"...\"` and `\"answer\": \"...\"`.\n    *   Ensure proper escaping of quotes within the answer strings if necessary (though not heavily needed here).\n    *   Validate the final JSON structure.\n\n7.  **Final Review:**\n    *   Check if the questions cover React, Python, and Fullstack aspects.\n    *   Are the questions appropriate for 5 years of experience? (Yes, they require more than basic knowledge).\n    *   Are the answers detailed and accurate?\n    *   Is the JSON format correct?\n    *   Does it meet all requirements of the original prompt? (Yes)."},
            {text: "```json\n[\n  {\n    \"question\": \"Describe a scenario where you would choose to use React's Context API versus a dedicated state management library like Redux or Zustand. What are the trade-offs?\",\n    \"answer\": \"I'd opt for the Context API for managing global state that doesn't change frequently or involves a relatively simple state structure, such as theme settings (dark/light mode) or user authentication status, especially within smaller to medium-sized applications or specific sub-trees. The main advantage is its built-in nature, requiring no extra dependencies and having a simpler API. \\n\\nTrade-offs: The primary drawback of Context API is performance-related. Any component consuming the context will re-render whenever *any* part of the context value changes, even if that specific component only cares about a part that didn't change. This can lead to unnecessary re-renders in complex applications with frequently updating state. Dedicated libraries like Redux or Zustand are often better optimized for performance with selectors that allow components to subscribe only to specific parts of the state, preventing unnecessary re-renders. They also typically offer better debugging tools (like Redux DevTools) and enforce a more structured approach, which can be beneficial in larger teams or more complex applications.\"\n  },\n  {\n    \"question\": \"In a Python backend (e.g., using Django or Flask), explain the N+1 query problem often encountered with ORMs. How would you identify and mitigate it?\",\n    \"answer\": \"The N+1 query problem occurs when an ORM executes one initial query to fetch a list of parent objects (the '1' query), and then subsequently executes N additional queries (one for each parent object) to fetch related child objects lazily. For example, fetching 10 blog posts and then iterating through them, accessing the author for each post, could result in 1 query for the posts and 10 separate queries for the authors (1 + 10 = 11 queries total).\\n\\nIdentification: This can often be identified by monitoring SQL queries during development (e.g., using Django Debug Toolbar, SQLAlchemy logging) or through application performance monitoring tools in production. A noticeable slowdown when dealing with lists of objects and their relations is a common symptom.\\n\\nMitigation: The solution is to fetch the related objects eagerly in the initial query. \\n- In Django ORM, you use `select_related()` for foreign key and one-to-one relationships (uses JOINs) and `prefetch_related()` for many-to-many and reverse foreign key relationships (uses separate 'IN' queries).\\n- In SQLAlchemy, you use loading strategies like `joinedload()` (uses JOINs) or `selectinload()` (uses separate 'IN' queries) within your query definition.\"\n  },\n  {\n    \"question\": \"Walk me through the typical flow of handling a user login request using JWT (JSON Web Tokens) between a React frontend and a Python backend.\",\n    \"answer\": \"1.  **Frontend (React):** User submits login credentials (e.g., email/password) via a form. React component sends these credentials in the body of a POST request to a specific login endpoint on the Python backend (e.g., `/api/auth/login`).\\n2.  **Backend (Python):** The backend receives the POST request. It validates the credentials against the user database (checking the hashed password). \\n3.  **Backend (Python):** If credentials are valid, the backend generates a JWT. This token typically contains a payload with user identification (like user ID, role) and expiration time, signed with a secret key.\\n4.  **Backend (Python):** The backend sends the JWT back to the frontend in the response body (often within a JSON object like `{'access_token': 'jwt_string'}`).\\n5.  **Frontend (React):** React receives the response. It extracts the JWT and typically stores it securely (e.g., in `localStorage`, `sessionStorage`, or potentially an HttpOnly cookie set by the server).\\n6.  **Frontend (React):** For subsequent authenticated requests to protected backend routes, React retrieves the stored JWT and includes it in the `Authorization` header, usually as `Authorization: Bearer <jwt_string>`.\\n7.  **Backend (Python):** On receiving requests to protected routes, a middleware or decorator on the backend extracts the JWT from the `Authorization` header, verifies its signature using the secret key, checks if it's expired, and if valid, identifies the user to process the request.\"\n  },\n  {\n    \"question\": \"When optimizing a React component, what's the difference between `React.memo`, `useMemo`, and `useCallback`? Provide a brief example scenario for each.\",\n    \"answer\": \"These are all tools for optimizing React performance by preventing unnecessary computations or re-renders:\\n\\n*   **`React.memo`**: This is a Higher-Order Component (HOC) used to wrap functional components. It memoizes the component, meaning React will skip re-rendering the component if its props haven't changed. It performs a shallow comparison of props by default.\\n    *   *Scenario:* Wrapping a presentational component that receives complex objects as props but only needs to re-render when those props actually change value, not just reference. Useful for list items or visual elements that don't change often.\\n\\n*   **`useMemo`**: This is a Hook used inside a functional component to memoize the result of an expensive calculation. It takes a function and a dependency array. The function is re-executed only when one of the dependencies changes. Otherwise, it returns the cached value.\\n    *   *Scenario:* Calculating a derived data structure from large props or state, like filtering or sorting a large list, which you don't want to recalculate on every render unless the source list or filter criteria change.\\n\\n*   **`useCallback`**: This is a Hook used inside a functional component to memoize a function definition. It takes a function and a dependency array. It returns a memoized version of the callback that only changes if one of the dependencies has changed. This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (like components wrapped in `React.memo`).\\n    *   *Scenario:* Passing an event handler function (e.g., `handleClick`) as a prop to a child component wrapped in `React.memo`. Without `useCallback`, a new function reference is created on every parent render, causing the child to re-render unnecessarily even if wrapped in `React.memo`. `useCallback` ensures the function reference remains stable.\"\n  },\n  {\n    \"question\": \"Imagine you're building a REST API endpoint in Python (using Flask/Django) to update a user's profile information. Which HTTP method would you primarily use, and what are some essential HTTP status codes you would return for success and different error conditions (e.g., user not found, invalid data)?\",\n    \"answer\": \"For updating a resource, I would primarily use the **`PATCH`** HTTP method if allowing partial updates (updating only specified fields), or **`PUT`** if requiring the client to send the complete resource representation for replacement. `PATCH` is generally more common and flexible for profile updates.\\n\\nEssential HTTP status codes would include:\\n\\n*   **Success:**\\n    *   `200 OK`: Typically returned if the update was successful and the response body contains the updated resource representation.\\n    *   `204 No Content`: Can be returned if the update was successful but there's no need to return the resource representation in the body.\\n*   **Client Errors:**\\n    *   `400 Bad Request`: Used when the request body contains invalid data (e.g., malformed JSON, failed validation rules like an invalid email format). Often accompanied by a response body detailing the validation errors.\\n    *   `401 Unauthorized`: Used if the user needs to be authenticated but hasn't provided valid credentials (e.g., missing or invalid JWT).\\n    *   `403 Forbidden`: Used if the authenticated user is not permitted to perform the update action on the specified resource (e.g., trying to update another user's profile without admin rights).\\n    *   `404 Not Found`: Used if the user resource identified by the URL (e.g., `/api/users/123`) does not exist.\\n*   **Server Error:**\\n    *   `500 Internal Server Error`: Used for unexpected server-side errors during processing (e.g., database connection issue, unhandled exception).\"\n  }\n]\n```"},
          ],
        },
      ],
    });
  
    const result = await chatSession.sendMessage("INSERT_INPUT_HERE");
    // TODO: Following code needs to be updated for client-side apps.
    const candidates = result.response.candidates;
    for(let candidate_index = 0; candidate_index < candidates.length; candidate_index++) {
      for(let part_index = 0; part_index < candidates[candidate_index].content.parts.length; part_index++) {
        const part = candidates[candidate_index].content.parts[part_index];
        if(part.inlineData) {
          try {
            const filename = `output_${candidate_index}_${part_index}.${mime.extension(part.inlineData.mimeType)}`;
            fs.writeFileSync(filename, Buffer.from(part.inlineData.data, 'base64'));
            console.log(`Output written to: ${filename}`);
          } catch (err) {
            console.error(err);
          }
        }
      }
    }
    console.log(result.response.text());
  